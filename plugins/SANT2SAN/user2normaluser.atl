-- @nsURI SAN=http://www.modelspartiti.org/templates/san/san
-- @nsURI SANT=http://www.modelspartiti.org/templates/san/sant
-- @nsURI Variant=http://www.modelspartiti.org/infrastructure/tmdl/scenario

module user2normaluser;
create OUT : SAN from IN : SANT, IN1 : Variant;

-- TODO trasformazione OutputGate
-- TODO generazione di casi più complessi
-- TODO Case con expression marking e variable
-- TOD utilizzare come input una List<Assignment> invece che la variant

-------------------------------------------------------------------------------
-- ATTRIBUTES -----------------------------------------------------------------
-------------------------------------------------------------------------------

-- attributo per salvare l'istanza della San
helper def : SANModel : SAN!SAN = OclUndefined;

-- attributo per salvare la Variant passata per la trasformazione
helper def : Variant : Variant!VariantAtomic = OclUndefined;
 
-------------------------------------------------------------------------------
-- HELPERS --------------------------------------------------------------------
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- RULES ----------------------------------------------------------------------
-------------------------------------------------------------------------------

-- Rule 'SANT2SAN'
-- questa rule genera una SAN!SAN dalla SANT.
-- vengono istanziati la Variant e la SAN per essere salvati negli attribute 
-- dichiarati, dopo di che procede alla inizializzazione dei Place e ad
-- istanziare le TimedActivity dalle TimedActivityTemplate.
rule SANT2SAN {
	from
		sant_model : SANT!SANT,
		variant : Variant!VariantAtomic
	to 
		san_model : SAN!SAN (
			name <- sant_model.name.concat(' Derivato')
		)
	do {
		-- salvo l'stanza della SAN
	    thisModule.SANModel <- san_model;
		-- salvo la Variant
	    thisModule.Variant <- variant;
	    thisModule.init_places(sant_model.places);
	   	thisModule.PlaceTemptoPlace(sant_model.templatePlaces);
	    thisModule.TimedActivityTemplateToTimedActivity(sant_model.activityTemplates->select(it | it.oclIsTypeOf(SANT!TimedActivityTemplate)));
	}
}

-- Called Rule 'init_places'
-- questa rule genera i SAN!Place all'interno della SAN già istanziati nella SANT.
-- una volta istanziato il primo place della Sequence viene accodato ai places
-- presenti nella istanza della SAN e successivamente viene verificato se ci sono
-- altri place da istanziare, nel caso la rule viene richiamata in modo ricorsivo.
-- IN: Sequence(SAN!Place) -> Places presenti nellla SANT
rule init_places(places : Sequence(SAN!Place)) {
	to 
		place_san : SAN!Place 
	do {
		place_san.name <- places.first().name;
		place_san.type <- places.first().type;
		place_san.marking <- places.first().marking;
		thisModule.SANModel.places <- thisModule.SANModel.places.append(place_san);
		
		if (places.size() > 1) {
			places <- places.subSequence(2,places.size());
			thisModule.init_places(places);
		}
	}
}

-- Rule 'InstantActivities'
-- questa rule genera le SAN!InstantaneousActivity all'interno della SAN 
-- dalle SANT!InstantaneousActivityTemplate presenti nella SANT.
-- una volta istanziata la InstantActivity viene accodato alle InstantActivities
-- presenti nella istanza della SAN.
rule InstantActivities {
	from
		instantActivity_sant : SANT!InstantaneousActivityTemplate
	to 
		instantActivity_san : SAN!InstantaneousActivity,
		case : SAN!Case (
			ID <- 0
		)
	do {
		case.p <- SAN!Expression.newInstance();
		case.p.segments <- SAN!ExpressionText.newInstance();
		case.p.segments.first().text <- '1.0';
		instantActivity_san.name <- instantActivity_sant.name;
		instantActivity_san.cases <- case;
		thisModule.SANModel.activities <- thisModule.SANModel.activities.append(instantActivity_san);
	}
}

-- Rule 'InputArcs'
-- questa rule genera le SAN!InputArc all'interno della SAN dai SANT!InputArc presenti
-- nella SANT una volta istanziato l' InputArc viene accodato agli InputArc presenti 
-- nella istanza della SAN.
rule InputArcs {
	from
		arc_temp : SANT!InputArc
	to 
		arc_san : SAN!InputArc 
	do{
		arc_san.source <- thisModule.SANModel.places->select(it | it.name = arc_temp.source.name).first(); -- nome place univoco?
		arc_san.target <- thisModule.SANModel.activities->select(it | it.name = arc_temp.target.name).first(); -- nome attività  univoco?
		thisModule.SANModel.arcs <- thisModule.SANModel.arcs.append(arc_san);
	}
}

-- Rule 'OutputArcs'
-- questa rule genera le SAN!OutputArc all'interno della SAN dai SANT!OutputArc presenti
-- nella SANT una volta istanziato l' OutputArc viene accodato agli OutputArc presenti 
-- nella istanza della SAN.
rule OutputArcs {
	from
		arc_temp : SANT!OutputArc
	to 
		arc_san : SAN!OutputArc
	do {
		arc_san.source <- thisModule.SANModel.activities->select(it | it.name = arc_temp.source.name).first().cases.first(); -- nome attività univoco?
		arc_san.target <- thisModule.SANModel.places->select(it | it.name = arc_temp.target.name).first(); -- nome place univoco?
		thisModule.SANModel.arcs <- thisModule.SANModel.arcs.append(arc_san);
	}
}

-- Called Rule 'concretizePlacesFromAssignment'
-- questa rule genera i SAN!Place all'interno della SAN attraverso i parametri, viene
-- richiamata all'interno della called rule PlaceTemptoPlace.
-- IN: String -> Prefisso del nome della place, Sequence(Real) -> Identificativi delle place
rule concretizePlacesFromAssignment( prefix: String, ids : Sequence(Real)) { -- TODO generazione Place che non hanno marking e type di default
	to 
		place : SAN!Place,
		marking : SAN!MarkingSimple,
		type : SAN!PrimitiveType
		
	do {
		place.name <- prefix.concat(ids.first().toString());
		place.marking <- marking;
		place.type <- type;
		
		thisModule.SANModel.places <- thisModule.SANModel.places.append(place);
		
		if( ids.size() > 1){
			ids <- ids.subSequence(2, ids.size());
			thisModule.concretizePlacesFromAssignment(prefix, ids);
		}
	}
}

-- Called Rule 'PlaceTemptoPlace'
-- questa rule genera i SAN!Place all'interno della SAN dai SANT!PlaceTemplate presenti nella SANT.
-- IN: Sequence(SANT!PlaceTemplate) -> PlacesTemplate presenti nella SANT di riferimento
rule PlaceTemptoPlace(places_templ : Sequence(SANT!PlaceTemplate)) {
	using{
		prefix : String = places_templ.first().name;
		assignment_values : Sequence(Real) = thisModule.Variant.assignments->select(it | it.parameter.name = places_templ.first().multiplicity.parameter.name).first().values; -- nome parameterArray univoco?
	}
	do {
		thisModule.concretizePlacesFromAssignment(prefix, assignment_values);
		
		if( places_templ.size() > 1){
			places_templ <- places_templ.subSequence(2, places_templ.size());
			thisModule.PlaceTemptoPlace(places_templ);
		}
	}
}

-- Called Rule 'ConnectCasesToPlaces'
-- questa rule genera i SAN!OutputArcs che collegano i case generati dalle SANT!TimedActivityTemplate
-- ai relativi place all'interno della SAN. 
-- Questa rule viene richiamata all'interno della rule 'TimedActivityTemplateToTimedActivity'
-- IN: Sequence(SAN!Case) -> case generati dalla TimedActivity, 
--     String -> Nome parametro con cui sono stati inizializzati i case per trovare il prefisso 
--				 delle place generate dal PlaceTemplate
--     Sequence(Real) -> Id dei place generati dal PlaceTemplate che sussegue il nome della place
rule ConnectCasesToPlaces(cases : Sequence(SAN!Case), caseParam_name : String, place_ids : Sequence(Real)) {
	using{
		prefix : String = SANT!PlaceTemplate.allInstancesFrom('IN')->select(it | it.multiplicity.parameter.name = caseParam_name).first().name;
		place : SAN!Place = thisModule.SANModel.places->select(it | it.name = prefix.concat(place_ids.first().toString())).first();
	}
	to 
		output_arc : SAN!OutputArc (
			source <- cases.first(),
			target <- place
		)
	do {
		thisModule.SANModel.arcs <- thisModule.SANModel.arcs.append(output_arc);
		
		if( cases.size() > 1){
			cases <- cases.subSequence(2, cases.size());
			place_ids <- place_ids.subSequence(2, place_ids.size());
			thisModule.ConnectCasesToPlaces(cases, caseParam_name, place_ids);
		}
	}
}

-- Called Rule 'TimedActivityTemplateToTimedActivity'
-- questa rule genera le SAN!TimedActivity all'interno della SAN dai SANT!TimedActivityTemplate presenti nella SANT.
-- IN: Sequence(SANT!TimedActivityTemplate) -> TimedActivityTemplat presenti nella SANT
rule TimedActivityTemplateToTimedActivity(activities_templ : Sequence(SANT!TimedActivityTemplate)) {
	using{
	-- variabile contenente la prima ActivityTemplate della SANT
	activity_templ : SANT!TimedActivityTemplate = activities_templ.first();
	-- variabile contenente il nome del parametro dell'AssignmentArray che contiene gli id delle place a cui è collegata la timed activity
	caseParam_name : String = activity_templ.casesTemplate.caseParameter.name;
	-- variabile contenente il nome del parametro dell'AssignmentArray che contiene i valori dei case
	paramValue_name : String = activity_templ.casesTemplate.pValues.name;
	-- Sequence contenente i valori da assegnare ai case
	assignment_values : Sequence(Real) = thisModule.Variant.assignments->select(it | it.parameter.name = paramValue_name).first().values;
	-- Sequence contenente gli id delle place a cui è collegata la timed activity
	place_ids : Sequence(Real) = thisModule.Variant.assignments->select(it | it.parameter.name = caseParam_name).first().values;
	-- indice per id dei case della TimedActivity
	count : Integer = 1;
	-- variabile di appoggio in cui salvare i case inizializzati
	cases : Sequence(SAN!Case) = Sequence{};
	-- variabili di appoggio per istanziare i case
	exp : SAN!Expression = OclUndefined;
	exp_text : SAN!ExpressionText = OclUndefined;
	case : SAN!Case = OclUndefined;
	}
	to
		timed_activity : SAN!TimedActivity(
		timeDistribution <- activity_templ.timeDistribution
		)
	do {
		timed_activity.name <- activity_templ.name;
		for (it in assignment_values) {
			case <- SAN!Case.newInstance();
			exp_text <- SAN!ExpressionText.newInstance(); 
			exp <- SAN!Expression.newInstance();
			case.ID <- count;
			exp_text.text <- it.toString();
		 	exp.segments <- exp_text;
		 	case.p <- exp;
		 	cases <- cases.append(case);
			count <- count + 1;
		}
		timed_activity.cases <- cases;
		
		thisModule.ConnectCasesToPlaces(cases, caseParam_name, place_ids);
		
		thisModule.SANModel.activities <- thisModule.SANModel.activities.append(timed_activity);
		
		if( activities_templ.size() > 1){
			activities_templ <- activities_templ.subSequence(2, activities_templ.size());
			thisModule.TimedActivityTemplateToTimedActivity(activities_templ);
		}
		
	}
}

-- Rule 'InputGateTemplate'
-- questa rule genera i SAN!InputGate all'interno della SAN dai SANT!InputGateTemplate presenti
-- nella SANT. Una volta istanziato l' InputGate viene accodato agli InputGate presenti 
-- nella istanza della SAN.
rule InputGateTemplate {
	from
		gate_imp : SANT!InputGateTemplate
	to 
		gate_san : SAN!InputGate (
			name <- gate_imp.name,
			activity <- SAN!Activity.allInstances()->select(it | it.name = gate_imp.activity.first().name), -- TODO effettuare controllo non solo alla prima activity ma a tutte
			function <- gate_imp.function,
			places <- gate_imp.places,
			predicate <- gate_imp.predicate
		)
	do{
		thisModule.SANModel.gates <- thisModule.SANModel.gates.append(gate_san).debug();
	}
}