-- @nsURI TPL=http://rcl.dsi.unifi.it/modeling/sba-templates.ecore
-- @nsURI JR=http://rcl.dsi.unifi.it/modeling/sba-joinrep.ecore
-- @atlcompiler atl2010

module tmdl2rjl;
create OUT : JR from IN : TPL;

--Global Variables
--helper def: modelID : Integer = 1;
helper def: ruleMapper : Map(TupleType(mrule: TPL!mergerule, m: JR!model),Sequence(JR!sharedstate)) = Map{};

helper def: stack: Sequence(JR!model) = Sequence{};
helper def: modelinfo: Map(JR!model, TupleType(t: TPL!template, idx: Integer, p: Map(String,TPL!value))) = Map{};
helper def: modelrole: Map(JR!model, TPL!block) = Map{};

---ENTRYPOINT
entrypoint rule system() {
	using {
		s : TPL!scenario = TPL!scenario->allInstances().debug()->first().debug(); -- debug per stampare l'oggetto sul quale viene chiamata
		s_out: JR!scenario = thisModule.scenario(s);
	}
	do {	
		--Create model instances
		s_out.root <- thisModule.instantiate(s.root,Sequence{1},Map{})->first();
		--Make unique names
		thisModule.makeUnique(s_out.root);
	
		--Compose instances
		thisModule.setSharedStates();
		
		--Write parameter values of atomic models in the output model
		thisModule.serializeParameters();
		
		s_out;
	}
}

rule instantiate(c: TPL!component, mult: Sequence(Integer), params: Map(String,TPL!value)) {
	using {
		p: Map(String,TPL!value) = Map{};
		out : Sequence(JR!model) = Sequence{}; 
	}
	do {
--		('>>>>> CALL instantiate / '+c.name).debug();
		
		for(a in c.assignments) {
			p <- p.including(a.ref.name,a.value);
		}
		--Union with passed parameters. Passed parameters have the precedence (overwrite the others)
		params <- params.union(p);
				
		out <- thisModule.instantiateFromTemplate(c.template, c.name, mult, params, c.subcomponents);
		out;
--		'>>>>> RETURN instantiate'.debug();
	}
}

rule instantiateDefaultSubcomponent(block: TPL!block, mult: TPL!multiplicity, params: Map(String,TPL!value)) {
	using {
		out: Sequence(JR!model) = Sequence{};
	}
	do {
		out <- thisModule.instantiateFromTemplate(block.ref, block.name, mult, params, Sequence{});
		out;
	}
}

rule instantiateFromTemplate(t: TPL!template, name: String, mult: Sequence(Integer), p: Map(String,TPL!value), subs: Sequence(TPL!instof)) {
	using {
		myMult: Sequence(Integer) = if mult.oclIsUndefined() then Sequence{1} else mult endif;
		tmp: JR!model = OclUndefined;
		tmpModels: Sequence(JR!model) = Sequence{};
		defaultSubs: Sequence(TPL!block) = if t.isAtomic() then Sequence{} else t.submodules endif;
		defaultParams: Sequence(TPL!param) = t.parameters;
		boundParams: Map(String,TPL!value) = Map{};
		blockMapping: Map(TPL!block,Sequence(JR!model)) = Map{};
		blockCurrent: TPL!block = OclUndefined;

		out: Sequence(JR!model) = Sequence{};
	}
	do {
--		('>>>>> CALL instantiateFromTemplate / '+ t.name + ' (' + name + ')').debug();

		--Find parameters for which a value has not been specified (params in 't.parameters' but not in 'p')
		for(par in defaultParams) {
			if(p.get(par.name) <> OclUndefined) {
				defaultParams <- defaultParams.excluding(par);
			}
		}
		--For each of them, add the parameter with the default value
		for(par in defaultParams) {
			p <- p.including(par.name, par.default);
		}
		
		if(t.isAtomic()) {	
			--Atomic template
			for(i in myMult) {
				tmp <- thisModule.build_atomic(t,name);
			
				out <- out->append(tmp);
				thisModule.modelinfo <- thisModule.modelinfo.including(tmp,Tuple{t=t,idx=i,p=p});
				thisModule.stack <- thisModule.stack.prepend(tmp);
			}
		}else{
			--Regular composition template (join)	
			for(i in myMult) {
				--Composition template (Join)						
				tmp <- thisModule.build_join(name);
				
				out <- out->append(tmp);
				thisModule.modelinfo <- thisModule.modelinfo.including(tmp,Tuple{t=t,idx=i,p=p});
				thisModule.stack <- thisModule.stack.prepend(tmp);
				
				--istanzia i sottocomponenti specificati nello scenario 
				for(s in subs) {
					--Setup bound parameters
					boundParams <- Map{};
					for(bind in t.bind->select(e | s.ref.template.parameters.includes(e.ref))) {
						boundParams <- boundParams.including(bind.ref.name, p.get(bind.source.name));				
					}
					--Find related block in the template
					blockCurrent <- s.role;
					if(blockCurrent.oclIsUndefined()) {
						blockCurrent <- t.submodules->select(e | e.ref = s.ref.template)->first();	
					}
					--actually instantiate submodules
					if(not s.replica.oclIsUndefined()) {
						--replica specification: the component should be replicated according to the replica template
						s.replica.debug();
						tmpModels <- thisModule.instantiateFromTemplate(s.replica, s.ref.name+'_rep', s.getMultiplicity(p), boundParams, Sequence{s});
						tmpModels.first().name <- tmpModels.first().name + '_' + subs.indexOf(s);

						tmp.submodels <- tmp.submodels->append(tmpModels).flatten();
						--and save the source block
						thisModule.modelrole <- thisModule.modelrole->including(tmpModels.first(),blockCurrent);
					}else{
						--normal subcomponent
						tmpModels <- thisModule.instantiate(s.ref, s.getMultiplicity(p), boundParams);
						for(m in tmpModels) {
							--For unique model names: covers the case in which a component is specified
							--multiple times as subcomponent of a given component, without using the mult parameter
							m.name <- m.name + '_' + subs.indexOf(s);
						}
						tmp.submodels <- tmp.submodels->append(tmpModels).flatten();
						--and save the source block
						for(t in tmpModels) {
							thisModule.modelrole <- thisModule.modelrole->including(t,blockCurrent);
						}
					}
				}
				--cerca i blocchi per cui è necessario creare componenti di default
				for(b in defaultSubs) { 
					if(not subs->select(e | e.ref.template = b.ref and (e.role = b or e.role = OclUndefined)).isEmpty()) {
						--se fra i sottocomponenti ce n'è uno che "copre" il blocco specificato,
						--allora non è necessario creare il default 
						defaultSubs <- defaultSubs.excluding(b);	
					}
				}
				--istanzia i componenti di default (se ce ne sono rimasti)
				for(b in defaultSubs) {
					--Setup bound parameters
					boundParams <- Map{};
					for(bind in t.bind->select(e | b.ref.parameters.includes(e.ref))) {
						boundParams <- boundParams.including(bind.ref.name, p.get(bind.source.name));
					}
					--actually instantiate default components
					tmpModels <- thisModule.instantiateDefaultSubcomponent(b, b.getMultiplicity(p), boundParams);
					tmp.submodels <- tmp.submodels->append(tmpModels).flatten();
					--and save the source block
					for(t in tmpModels) {
						thisModule.modelrole <- thisModule.modelrole->including(t,b);
					}
				}
			}
		}
		
		out;
--		'>>>>> RETURN instantiateFromTemplate'.debug();
	}
}

rule makeUnique(m: JR!model) {
	using{
		subs: Sequence(JR!model) = Sequence{};
	}
	do {
		if(m.refImmediateComposite() <> OclUndefined) {
			m.name <- m.refImmediateComposite().name + '_' + m.name;
		}
		if(m.oclIsKindOf(JR!join)) {
			subs <- m.submodels;
		}else if(m.oclIsKindOf(JR!rep)){
			subs <- subs.including(m.submodel);			
		}
		m.name <- m.name + '[' + m.getPrefix() + thisModule.modelinfo.get(m).idx + ']';
		
		for(s in subs) {
			thisModule.makeUnique(s);	
		}
	}
}

---Populate shared states
rule setSharedStates() {
	using {
		tmp : Sequence(JR!sharedstate) = Sequence{};
	}
	do {
		for(model in thisModule.stack) {
			--skip atomic models: they do not have merge rules to apply
			if (not model.oclIsKindOf(JR!submodel)) {
				for(s in thisModule.modelinfo.get(model).t.mergerules) {
					tmp <- thisModule.applyMergeRule(s,model);
					thisModule.ruleMapper <- thisModule.ruleMapper.including(Tuple{mrule=s,m=model},tmp);
					model.sharedstates <- model.sharedstates->append(tmp)->flatten();				
				}
			}
		}
	}
}

rule applyMergeRule(r : TPL!mergerule, m : JR!model) {
	using {
		out : Sequence(JR!sharedstate) = Sequence{};
		tmp : JR!sharedstate = OclUndefined;
		selItems : Sequence(TPL!mergeitem) = if r.oclIsKindOf(TPL!forward) then Sequence{r.ref} else r.ref endif;
		selModels : Sequence(JR!model) = Sequence{};
		targetItems : Sequence(TupleType(m: JR!model, name: String)) = Sequence{};
		myName : String = r.name + '[' + r.refImmediateComposite().getPrefix() + thisModule.modelinfo.get(m).idx + ']';
		split: Sequence(String) = Sequence{};
		mergeSet: Set(String) = Set{};
		mergePattern: Map(String,Set(String)) = Map{};
	}
	do {
		('## [' + m.toString() + ']'+r.oclType().toString()+': '+r.name.toString()).debug();

		for(sh in selItems) {
			sh.toString().debug();
			--Selects involved componentes
			selModels <- m.getSubs()->select(i | (thisModule.modelinfo.get(i).t = sh.item.refImmediateComposite())
													or i.isReplicaOf(sh.item.refImmediateComposite()));

			--If a block has been specified, select only models corresponding to that block
			if(not sh.block.oclIsUndefined()) {
				selModels <- selModels->select(e | (thisModule.modelrole.get(e) = sh.block));
			}
			--If ids have been specified, select only models corresponding to such ids
			if(not sh.ids.oclIsUndefined()) {
				selModels <- selModels->select(e | sh.ids.resolve(thisModule.modelinfo.get(e).p)->includes(thisModule.modelinfo.get(e).idx));	
			}

			for(model in selModels) {
				--For all submodels of m that are originated from a rule of the same type as the one referenced
				--by the shared-state variable that is processed, expand the variable
				if(sh.item.oclIsKindOf(TPL!interf)) {
					--It is a single interface, just add it to the target items
					targetItems <- targetItems.append(Tuple{m=model,name=sh.item.name});
				}
				else if(sh.item.oclIsKindOf(TPL!interfarray)) {
					--It is an array of atomic interfaces: resolve the multiplicity
					for(i in sh.item.mult.resolve(thisModule.modelinfo.get(model).p)) {
						targetItems <- targetItems.append(Tuple{m=model,name=sh.item.name + '[' + sh.item.getPrefix() + i + ']'});
					}
				}
				else{
					--It is a composed interface: find all the corresponding interfaces of generated instances
					if(thisModule.ruleMapper.get(Tuple{mrule=sh.item,m=model}).oclIsUndefined()) {
						--Can happen with "intelligent" handling of replica
						--In this case find the corresponding element in the replica
						targetItems <- targetItems.append(thisModule.ruleMapper.get(Tuple{mrule=sh.item,m=model.submodel})->
																collect(e | Tuple{m=model,name=e.name}));
					}else{
						targetItems <- targetItems.append(thisModule.ruleMapper.get(Tuple{mrule=sh.item,m=model})->
																collect(e | Tuple{m=model,name=e.name}));
					}
				}
			}
		}

		targetItems <- targetItems.flatten();

--		'<<<<<TARGET ITEMS>>>>>>'.debug();
		targetItems.size().debug();
		if(not targetItems.isEmpty()) {
			if(r.oclIsKindOf(TPL!mergeall)) {
				--mergeall elements
				tmp <- thisModule.newSharedState(myName);
				tmp.childs <- targetItems->collect(e | thisModule.newStateVariable(e.m,e.name));
				out <- out.append(tmp);
			}else if(r.oclIsKindOf(TPL!forward)) {
				--forward elements
				for(e in targetItems) {
					if(e.m.getPrefix().size()>0 and e.name->indexOf(e.m.getPrefix()) > 0) {
						--The item has already prefix+index: find it and forward it	
						myName <- r.name;
						myName <- myName + '[' + e.name->split('\\[')->select(part | part.indexOf(e.m.getPrefix())>=0).first();					
					}else{
						--Take the name of the rule..
						myName <- r.name;
						--..append other already existing in the targetItem..
						myName <- myName + e.name->split('\\[')->collect(part | if part.indexOf('$')>=0 then '['+part else '' endif)->sum();
						--..and finally append the prefix+index of the current model
						myName <- myName + '[' + e.m.getPrefix() + thisModule.modelinfo.get(e.m).idx + ']'; 	
					} 		
					tmp <- thisModule.newSharedState(myName);
					tmp.childs <- tmp.childs.append(thisModule.newStateVariable(e.m,e.name));
					out <- out.append(tmp);
				}
			}else if(r.oclIsKindOf(TPL!mergebyname)) {
				--mergebyname elements	
				for(str in targetItems) {
					mergeSet <- Set{};
					split <- str.name.split('\\[');
					for(part in split->excluding(split->first())) {
						part.debug();
						r.getPrefixes().debug();
						part->split('\\$').first().debug();
						'...'.debug();
						if (r.getPrefixes().isEmpty() or r.getPrefixes()->includes(part.split('\\$').first())) {
							mergeSet <- mergeSet->including('[' + part);
							'IN'.debug();
						}
					}
					split <- str.m.name.split('\\[');
					for(part in split->select(e | e.indexOf('$')>0)) {
						part.debug();
						if (r.getPrefixes().isEmpty() or r.getPrefixes()->includes(part.split('\\$').first())) {
							mergeSet <- mergeSet->including('[' + part);
						}
					}
					mergePattern <- mergePattern.including(str,mergeSet);
				}
					
				for(i in mergePattern.getValues().asSet()) {
					if(i->isEmpty()) {
						--Un unico insieme vuoto: non sono stati trovati elementi che matchano,
						-- si comporta come forward.
						for(e in targetItems) {
							if(e.m.getPrefix().size()>0 and e.name->indexOf(e.m.getPrefix()) > 0) {
								--The item has already prefix+index: find it and forward it	
								myName <- r.name;
								myName <- myName + '[' + e.name->split('\\[')->select(part | part.indexOf(e.m.getPrefix())>=0).first();					
							}else{
								--Take the name of the rule..
								myName <- r.name;
								--..append other already existing in the targetItem..
								myName <- myName + e.name->split('\\[')->collect(part | if part.indexOf('$')>=0 then '['+part else '' endif)->sum();
								--..and finally append the prefix+index of the current model
								myName <- myName + '[' + e.m.getPrefix() + thisModule.modelinfo.get(e.m).idx + ']'; 	
							} 		
							tmp <- thisModule.newSharedState(myName);
							tmp.childs <- tmp.childs.append(thisModule.newStateVariable(e.m,e.name));
							out <- out.append(tmp);
						}
					}else{
						tmp <- thisModule.newSharedState(myName + i.sum());
						tmp.childs <- mergePattern.getKeys()->
										select(k | mergePattern->get(k) = i)->
										collect(e | thisModule.newStateVariable(e.m,e.name));
						out <- out.append(tmp);
					}
				}
			}
		}
			
		out;	--returns "out"
	}	
}

rule serializeParameters() {
	using {
		p: Map(String,TPL!value) = Map{};	
	}
	do {
		for(m in JR!submodel.allInstances()) {
			p <- thisModule.modelinfo.get(m).p;
			p.debug();
			for(param in p.getKeys()) {
				param.debug();
				p.get(param).debug();
				m.parameters <- m.parameters.append(thisModule.parameter(param,p.get(param)));	
			}
		}
	}
}

---Creates a new JR!sharedstate element
lazy rule newSharedState {
	from 
		str : String
	to
		s : JR!sharedstate
		(
			name <- str
		)
}

---Creates a new JR!statevariable element
lazy rule newStateVariable {
	from
		m : JR!model, 
		n : String
	to 
		s : JR!statevariable
		(
			model <- m,
			state <- n
		)
}

lazy rule build_atomic {
	from
		t: TPL!atomic,
		name: String
	to
		s : JR!submodel
		(
			source <- t.body,
			name <- name
		)
}

lazy rule build_join {
	from
		name: String
	to
		m: JR!join 
		(
			name <- name
		)
}

lazy rule build_rep {
	from 
		name: String
	to 
		r: JR!rep
		(
			name <- name	
		)
}

lazy rule parameter {
	from 
		n: String, 	
		v: TPL!value
	to 
		p: JR!parameter 
		(
			name <- n,
			val <- v.toJR()
		)
}

lazy rule scenario {
	from
		s: TPL!scenario
	to
		sout: JR!scenario
		(
			name <- s.root.name
		)
}

lazy rule value_int {
	from
		v: Integer
	to 
		vout: JR!value_int ( value <- v )
}
lazy rule value_double {
	from
		v: Real
	to 
		vout: JR!value_double ( value <- v )
}
lazy rule array_int {
	from
		v: TPL!array_int
	to 
		vout: JR!value_int_array
		( 
			values <- v.values->collect(e | e.value)
		)
}
lazy rule array_double {
	from
		v: TPL!array_double
	to 
		vout: JR!value_double_array
		( 
			values <- v.values->collect(e | e.value)
		)
}

--Generic helpers
helper def: join(s: Sequence(String)) : String =
	let out: String = '' in s->collect(e | out.concat(e));

--TPL helpers
---Is the template an atomic template?
helper context TPL!template def: isAtomic() : Boolean = self.oclIsTypeOf(TPL!atomic);
---Is the template a replica template?
helper context TPL!template def: isReplice() : Boolean = 
	if self.isAtomic() then false else self.replica endif;

---Generates a sequence of integers 1...n from an integer number n
helper context Integer def: toSequence() : Sequence(Integer) = 
	if self > 0 then
		(self-1).toSequence()->append(self)
	else 
		Sequence{}
	endif;
helper context TPL!assign def: toSequence() : Sequence(OclAny) = self.value.toSequence();
helper context TPL!value_int def: toSequence() : Sequence(Integer) = self.value.toSequence();
helper context TPL!value_double def: toSequence() : Sequence(Real) = self.value.toSequence();
helper context TPL!array_int def: toSequence() : Sequence(Integer) = self.values->collect(e | e.value);
helper context TPL!array_double def: toSequence() : Sequence(Real) = self.values->collect(e | e.value);

helper context TPL!value_int def: toString() : String = self.value.toString();
helper context TPL!value_double def: toString() : String = self.value.toString();
helper context TPL!array_int def: toString() : String = self.values->collect(e | e.toString());
helper context TPL!array_double def: toString() : String = self.values->collect(e | e.toString());

helper context TPL!value_int def: toJR() : JR!value_int = thisModule.value_int(self.value);
helper context TPL!value_double def: toJR() : JR!value_double = thisModule.value_double(self.value);
helper context TPL!array_int def: toJR() : JR!value_int_array = thisModule.array_int(self);
helper context TPL!array_double def: toJR() : JR!value_double_array = thisModule.array_double(self);

---Resolves a 'multiplicity' value based on a set of parameter values
helper context TPL!multiplicity def: resolve(p : Map(String,TPL!value)) : Sequence(Integer) =
	--if it is a parameter then find the value in the parameter list
	if self.oclIsTypeOf(TPL!paramref) then
		--if it is in the parameter list then select the value
		if not p.get(self.ref.name).oclIsUndefined() then
			p.get(self.ref.name).toSequence()
		else	--else use the default value
			self.ref.default.toSequence()
		endif
	else
		self.toSequence()
	endif;

helper context TPL!param def: getValue(m : TPL!model) : TPL!param_value =
	if m.oclIsUndefined() then
		if TPL!parambinding.allInstances()->select(pb | pb.ref = self)->size() > 0 then
			1
		else
			self.default
		endif
	else
		if not m.assignments.oclIsUndefined() then	--if parameters exist
			let v: TPL!param_value = m.assignments->select(par | par.ref = self)->first() in
			if v.oclIsUndefined() then 
				self.default	--if the parameter instance is not found return the default value
			else v.value endif		--else return the value of the parameter instance
		else self.default endif	--else return the default value
	endif;
	
helper context TPL!instof def: getMultiplicity(p: Map(String,TPL!value)) : Sequence(Integer) =
	if self.mult.oclIsUndefined() then
		1.toSequence()
	else
		self.mult.resolve(p)
	endif;
helper context TPL!block def: getMultiplicity(p: Map(String,TPL!value)) : Sequence(Integer) =
	if self.mult.oclIsUndefined() then
		Sequence{}
	else
		self.mult.resolve(p)
	endif;

helper context TPL!template def: getPrefix() : String = 
	let s: String = self.prefix in
	if s.oclIsUndefined() then '' else (s+'$') endif;

helper context TPL!mergebyname def: getPrefixes() : Sequence(String) =
	let s: Sequence(String) = self.prefixes in
	if s.oclIsUndefined() then Sequence{} else s endif;

helper context TPL!interfarray def: getPrefix() : String =
	let s: String = self.prefix in
	if s.oclIsUndefined() then '' else (s+'$') endif;

helper context TPL!mergeitem def: toString() : String =
	self.item.refImmediateComposite().toString() + '.' + self.item.name;

--JR helpers
helper context JR!model def: getSubs() : Sequence(JR!model) =
	if self.oclIsTypeOf(JR!submodel) then Sequence{}
	else
		if self.oclIsTypeOf(JR!rep) then Sequence{self.submodel}
		else self.submodels endif
	endif;

helper context JR!model def: isReplicaOf(refT: TPL!template) : Boolean =
	if self.oclIsTypeOf(JR!rep) then
		let r: JR!rep = self in
		thisModule.modelinfo.get(r.submodel).t = refT 
	else
		false
	endif;

helper context JR!statevariable def: toString() : String =
	self.state + '->' + self.model;

helper context JR!model def: getPrefix() : String = 
	thisModule.modelinfo.get(self).t.getPrefix();

----- DEBUG: Creates a placeholder (to be able to serialize incomplete models)
--rule fake_model() {
--	to
--		s : JR!submodel
--		(
--			source <- 'FAKE',
--			name <- 'FAKE'
--		)
--		do {
--			s.name <- s.name + thisModule.modelID;
--			thisModule.modelID <- thisModule.modelID + 1;
--			s;
--		}
--}
----- DEBUG: Creates a placeholder (to be able to serialize incomplete models)
--rule fake_shared() {
--	to
--		s : JR!sharedstate
--		(
--			childs <- Sequence{sv}
--		),
--		sv : JR!statevariable
--		(
--			state <- 'Fake',
--			model <- JR!submodel.allInstances().first()
--		)
--		do {
--			s.name <- 'FAKE' + thisModule.modelID;
--			thisModule.modelID <- thisModule.modelID + 1;
--			s;
--		}
--}